// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "sury/src/S.res.mjs";
import * as JSONSchema from "sury/src/JSONSchema.res.mjs";

function arrayable(base) {
  return S.union([
              S.transform(base, (function (s) {
                      return {
                              p: (function (base) {
                                  return base;
                                }),
                              s: (function (obj) {
                                  var base = JSONSchema.Arrayable.classify(obj);
                                  if (base.TAG === "Single") {
                                    return base._0;
                                  } else {
                                    return s.fail("Can't convert multiple to single", undefined);
                                  }
                                })
                            };
                    })),
              S.transform(S.array(base), (function (s) {
                      return {
                              p: (function (base) {
                                  return base;
                                }),
                              s: (function (obj) {
                                  var base = JSONSchema.Arrayable.classify(obj);
                                  if (base.TAG === "Single") {
                                    return s.fail("Can't convert single to multiple", undefined);
                                  } else {
                                    return base._0;
                                  }
                                })
                            };
                    }))
            ]);
}

var typeName = S.union([
      S.literal("string"),
      S.literal("number"),
      S.literal("integer"),
      S.literal("boolean"),
      S.literal("object"),
      S.literal("array"),
      S.literal("null")
    ]);

var t = S.recursive(function (t) {
      var definition = S.union([
            S.transform(t, (function (s) {
                    return {
                            p: (function (base) {
                                return base;
                              }),
                            s: (function (obj) {
                                if (typeof obj === "object") {
                                  return obj;
                                } else {
                                  return s.fail("Can't convert bool to schema", undefined);
                                }
                              })
                          };
                  })),
            S.transform(S.bool, (function (s) {
                    return {
                            p: (function (base) {
                                return base;
                              }),
                            s: (function (obj) {
                                if (typeof obj === "object") {
                                  return s.fail("Can't convert schema to bool", undefined);
                                } else {
                                  return obj;
                                }
                              })
                          };
                  }))
          ]);
      var dependency = S.union([
            S.transform(t, (function (s) {
                    return {
                            p: (function (base) {
                                return base;
                              }),
                            s: (function (obj) {
                                if (typeof obj === "object" && !Array.isArray(obj)) {
                                  return obj;
                                } else {
                                  return s.fail("Can't convert required to schema", undefined);
                                }
                              })
                          };
                  })),
            S.transform(S.array(S.string), (function (s) {
                    return {
                            p: (function (base) {
                                return base;
                              }),
                            s: (function (obj) {
                                if (typeof obj === "object" && !Array.isArray(obj)) {
                                  return s.fail("Can't convert schema to required", undefined);
                                } else {
                                  return obj;
                                }
                              })
                          };
                  }))
          ]);
      return S.object(function (s) {
                  return {
                          $id: s.f("$id", S.option(S.string)),
                          $ref: s.f("$ref", S.option(S.string)),
                          $schema: s.f("$schema", S.option(S.string)),
                          $defs: s.f("$defs", S.option(S.dict(definition))),
                          type: s.f("type", S.option(arrayable(typeName))),
                          enum: s.f("enum", S.option(S.array(S.json(true)))),
                          const: s.f("const", S.option(S.json(true))),
                          multipleOf: s.f("multipleOf", S.option(S.$$float)),
                          maximum: s.f("maximum", S.option(S.$$float)),
                          exclusiveMaximum: s.f("exclusiveMaximum", S.option(S.$$float)),
                          minimum: s.f("minimum", S.option(S.$$float)),
                          exclusiveMinimum: s.f("exclusiveMinimum", S.option(S.$$float)),
                          maxLength: s.f("maxLength", S.option(S.$$int)),
                          minLength: s.f("minLength", S.option(S.$$int)),
                          pattern: s.f("pattern", S.option(S.string)),
                          items: s.f("items", S.option(arrayable(definition))),
                          additionalItems: s.f("additionalItems", S.option(definition)),
                          maxItems: s.f("maxItems", S.option(S.$$int)),
                          minItems: s.f("minItems", S.option(S.$$int)),
                          uniqueItems: s.f("uniqueItems", S.option(S.bool)),
                          contains: s.f("contains", S.option(t)),
                          maxProperties: s.f("maxProperties", S.option(S.$$int)),
                          minProperties: s.f("minProperties", S.option(S.$$int)),
                          required: s.f("required", S.option(S.array(S.string))),
                          properties: s.f("properties", S.option(S.dict(definition))),
                          patternProperties: s.f("patternProperties", S.option(S.dict(definition))),
                          additionalProperties: s.f("additionalProperties", S.option(definition)),
                          dependencies: s.f("dependencies", S.option(S.dict(dependency))),
                          propertyNames: s.f("propertyNames", S.option(definition)),
                          if: s.f("if", S.option(definition)),
                          then: s.f("then", S.option(definition)),
                          else: s.f("else", S.option(definition)),
                          allOf: s.f("allOf", S.option(S.array(definition))),
                          anyOf: s.f("anyOf", S.option(S.array(definition))),
                          oneOf: s.f("oneOf", S.option(S.array(definition))),
                          not: s.f("not", S.option(definition)),
                          format: s.f("format", S.option(S.string)),
                          contentMediaType: s.f("contentMediaType", S.option(S.string)),
                          contentEncoding: s.f("contentEncoding", S.option(S.string)),
                          definitions: s.f("definitions", S.option(S.dict(definition))),
                          title: s.f("title", S.option(S.string)),
                          description: s.f("description", S.option(S.string)),
                          default: s.f("default", S.option(S.json(true))),
                          readOnly: s.f("readOnly", S.option(S.bool)),
                          writeOnly: s.f("writeOnly", S.option(S.bool)),
                          examples: s.f("examples", S.option(S.array(S.json(true))))
                        };
                });
    });

export {
  arrayable ,
  typeName ,
  t ,
}
/* typeName Not a pure module */
